[[apim-kubernetes-operator-ingress-controller]]
= How to use Gravitee as an ingress controller for your Kubernetes cluster
:page-sidebar: apim_3_x_sidebar
:page-permalink: apim/3.x/apim_kubernetes_operator_ingress_controller.html
:page-folder: apim/kubernetes
:page-layout: apim3x

== Overview

In this section we will walk you through the steps needed to deploy the Gravitee gateway as an ingress runtime along with the Gravitee Kubernetes Operator acting as an Ingress controller.

=== Limitations
When using the `graviteeio` ingress class, as we will describe shortly, some features defined in the Kubernetes Ingress specification are not supported at this time.
Here is the list of unsupported features linked to there respective description for further details:

* link:{{ 'https://kubernetes.io/docs/concepts/services-networking/ingress/#resource-backend' }}[Resource Backends]
* link:{{ 'https://kubernetes.io/docs/concepts/services-networking/ingress/#hostname-wildcards' }}[Hostname Wildcards]

=== Overview

The Gravitee gateway will be deployed in the gravitee-ingress namespace and will be available at the graviteeio.example.com domain name.

Our backend service(s) routed made available through our ingress(es) will be deployed in the gravitee-apis namespace.

Finally, the APIM components used e.g. to gather analytics or review or configuration will be deployed in the gravitee-apim namespace.

image:{% link /images/apim/3.x/kubernetes/gko-architecture-4-ingress.png %}[]

=== Prerequisites

A basic knowledge of link:{{ 'https://helm.sh/docs/' }}[helm] and link:{{ 'https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands' }}[kubectl] command line tools is required to follow the steps described in the next sections.

For the sake of brevity we will assume that link:{{ 'https://github.com/kubernetes-sigs/external-dns' }}[external-dns] has been configured to handle domain name resolution on your  cluster.

=== Step 1 - Configure your deployment

In the next step, we will install the gateway that will act as our Ingress runtime using the link:{{ '/apim/3.x/apim_installguide_kubernetes.html' | relative_url }}[gravitee.io helm charts].

Here is the minimum set of properties that your Helm values should contain to make the Gateway act as an Ingress runtime on your Kubernetes cluster.

[source,yaml]
----
# values.yml
gateway:
  services:
    sync:
      kubernetes:
        enabled: true
  ingress:
    enabled: false
  service:
    type: LoadBalancer
    annotations:
      external-dns.alpha.kubernetes.io/hostname: graviteeio.example.com
    externalPort: 443
----

In the values you can see that the ingress is disabled. We do not want NGINX to act as an Ingress runtime as the gateway will be handling inbound trafic.

The external-dns.alpha.kubernetes.io/hostname instructs external-dns  to create a DNS entry matching the load balancer service IP using your external DNS provider.

=== Step 2 - Deploy your gateway

We can now install the gateway using the following command:

[source,bash]
----
helm upgrade --install gravitee-ingress \
  -n gravitee-ingress \
  -f values.yml \
  graviteeio/apim3
----

=== Step 3 - Deploy the Gravitee Kubernetes Operator

Just like we did for the gateway, we can install the Gravitee Kubernetes Operator that will act as our Ingress controller using the gravitee.io helm charts. You can find the operator helm chart documentation link:{{ '/apim/3.x/apim_kubernetes_operator_installation.html' | relative_url }}[here].

[source,yaml]
----
helm upgrade --install gravitee-gko \
  -n gravitee-ingress \
  graviteeio/gko
----

=== Step 4 - Add a test backend

To be able to test our installation, we will deploy link:{{ 'https://github.com/mccutchen/go-httpbin' }}[go-httpbin] as a backend service routed through our ingress resource. The following snippet defines the minimum resources required to get our backend service up and running.

[source,yaml]
----
# httpbin.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: httpbin
  labels:
    type: httpbin
spec:
  replicas: 1
  selector:
    matchLabels:
      type: httpbin
  template:
    metadata:
      labels:
        type: httpbin
    spec:
      containers:
        - name: httpbin
          image: mccutchen/go-httpbin
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
            - name: USE_REAL_HOSTNAME
              value: "true"
---
apiVersion: v1
kind: Service
metadata:
  name: httpbin
  labels:
    type: httpbin
spec:
  ports:
    - port: 8080
      targetPort: 8080
  selector:
    type: httpbin
----

Apply the resources on your cluster using the following command:

[source,bash]
----
kubectl apply -f httpbin.yaml
----

=== Step 5 - Define your ingress

Once the `httpbin` service created, it can be used as a reference in one or more ingress resources. The example below specifies the rules for routing traffic to your backend service. The Gravitee Kubernetes Operator's ingress controller will then interpret this ingress resource and publish a new API on the Gravitee Gateway. The Gateway will act as a runtime ingress, handling traffic and forwarding it to your backend service.

[source,yaml]
----
# httpbin-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: httpbin-ingress
  annotations:
    kubernetes.io/ingress.class: graviteeio
spec:
  rules:
    - http:
        paths:
          - path: /httpbin
            pathType: Prefix
            backend:
              service:
                name: httpbin
                port:
                  number: 8000
----

Apply the Ingress on your cluster using the following command:

[source,bash]
----
kubectl apply -f httpbin-ingress.yaml
----

=== Step 6 - Test your installation

You can now test your installation by sending a request to your ingress resource. Having these settings you should be able to call the gateway and your ingress in a secured way.

[source,bash]
----
curl -i https://graviteeio.example.com/httpbin/hostname
----

=== Secure your Gateway and Ingress Resources
In order to secure the connection between your client and the gateway, you need to make some changes in the Gateway ConfigMap but before that we need a keystore then we have to add that to the cluster. You can create a keystore using the following command:
(please be aware that we only support "jks" keystore at the moment)

[source,bash]
----
keytool -genkeypair -alias example.com -storepass changeme -keypass changeme \
-keystore gw-keystore.jks -dname "CN=example.com"
----

Once you have your keystore, now you should add it to your target namespace (it is default in here)

[source,bash]
----
kubectl create secret generic gw-keystore \
--from-file=keystore=gw-keystore.jks
----

Once you have the keystore added to the cluster, now you need to configure the Gateway to use this keystore and also enable the HTTPS. Open the ConfigMap that includes the gateway configuration and add the following configuration to the http (or listeners.https) section:


You also need to add this label to your gateway Configmap
this will let the controller to find out where your Gateway configuration is locate

[source,yaml]
----
 http:
   secured: true # Turns on the https
   ssl:
     keystore:
       type: jks
       kubernetes: /default/secrets/gw-keystore/keystore
       password: changeme
     sni: true
----

Now you need to restart the gateway so the changes will take place.

There are 2 ways that you let GKO to modify your keystore and add or updates your key pairs:

1) Either add the following label to your exiting Gateway ConfigMap

[source,bash]
----
gravitee.io/component=gateway
----

2) Or create a new secret and provide the name of the Gateway keystore and its password

[source,bash]
----
kubectl create secret generic gw-keystore-config \
-n default \
--from-literal=name=gw-keystore \
--from-literal=password=changeme
----


You also need to label this new secret. So just add the folloing label to it:

[source,bash]
----
gravitee.io/gw-keystore-config=true
----


And that's all you have to do to configure both the Gateway and GKO. Now it is time to add TLS to your ingress resources

=== Add TLS to the ingress resources
Assuming that you already have a keypair for you host and added it to the cluster (https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets)
Now you can reference the secret inside your ingress file. (the secret must be in the same namespace)

[source,yaml]
----
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tls-example
  annotations:
    kubernetes.io/ingress.class: graviteeio
spec:
  tls:
  - hosts:
      - foo.com
    secretName: foo.com
  rules:
  - host: foo.com
    http:
      paths:
      - path: /httpbin
        pathType: Prefix
        backend:
          service:
            name: svc-1
            port:
              number: 8080
----

Having this settings you should be able to call the gateway and your ingress in a secured way.

[source,bash]
----
curl -v https://foo.com/httpbin
----

Or if it is a self-signed certificate

[source,bash]
----
curl --insecure -v https://foo.com/httpbin
----