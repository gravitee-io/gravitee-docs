= Expression Language
:page-sidebar: apim_3_x_sidebar
:page-permalink: apim/3.x/apim_publisherguide_expression_language.html
:page-folder: apim/user-guide/publisher
:page-layout: apim3x

The Gravitee.io Expression Language (EL for short) is one of the key feature
that can be used by API publisher to configure several points / services of an API.

This expression language is a powerful language that support querying and
manipulating an object graph and is based on the great http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html[SpEL] (Spring Expression Language).
This also mean that you can do exactly all the things described in the previous
link.

Gravitee.io is extending SpEL capabilities by providing useful objects and properties
inside the expression language context.

== Syntax
The Expression Language syntax is as follow:

`{#request.id}`

== API
=== Properties

As an API publisher, you can define properties for your API. These properties are
automatically _injected_ into the expression language context to be used later.

=== Example

* Get the value of the property `my-property` defined in API properties:
`{#properties['my-property']}`

=== Endpoints
When defining endpoints for your API, you must have to give them a _name_ which
must be a unique identifier across all the endpoints of this API.

Once done, this identifier can be used to get an endpoint reference (ie. uri).

For example: when you're creating an API, a _default_ endpoint is created,
corresponding to the value you set for the backend property. This endpoint can
be retrieved using EL by using the following syntax:

`{#endpoints['default']}`

== Request
=== Properties
|===
.^|Property      |Description            ^.^|Type            |Example

.^|id            |Identifier             ^.^|string          |12345678-90ab-cdef-1234-567890ab
.^|transactionId |Transaction identifier ^.^|string          |cd123456-7890-abcd-ef12-34567890
.^|uri           |URI                    ^.^|string          |/v2/store/MyStore?order=100
.^|path          |Path                   ^.^|string          |/v2/store/MyStore
.^|paths         |Path parts             ^.^|array of string |[,v2,store,MyStore]
.^|pathInfo      |Path info              ^.^|string          |/store/MyStore
.^|pathInfos     |Path info parts        ^.^|array of string |[,store,MyStore]
.^|contextPath   |Context path           ^.^|string          |/v2/
.^|params        |Query parameters       ^.^|key / value     |order -> 100
.^|pathParams    |Path parameters        ^.^|key / value     |storeId -> MyStore (__see Warning for details__)
.^|headers       |Headers                ^.^|key / value     |X-Custom -> myvalue
.^|method        |HTTP method            ^.^|string          |GET
.^|scheme        |HTTP scheme            ^.^|string          |http
.^|version       |HTTP version           ^.^|string          |HTTP_1_1
.^|timestamp     |Timestamp              ^.^|long            |1602781000267
.^|remoteAddress |Remote address         ^.^|string          |0:0:0:0:0:0:0:1
.^|localAddress  |Local address          ^.^|string          |0:0:0:0:0:0:0:1
.^|content       |Body content           ^.^|string          |-
|===

[WARNING]
====
* `{#request.content}` is only available when the policy is bound to an `on-request-content` phase.
* `{#request.pathParams}` keys  are based on the path defined in policies configuration. For the example above, the defined path is `/store/:storeId`
====
=== Example

* Get the value of the `Content-Type` header for an incoming HTTP request:
`{#request.headers['content-type']}`

* Get the second part of the request path:
`{#request.paths[1]}`

== Request context
=== Properties
|===
|Property |Description |Type |Always present

.^|attributes
|Request context attributes
^.^|key-value
^.^|X
|===

=== Attributes
When the gateway handles an incoming HTTP request, some attributes are
automatically created. These attributes are:

|===
|Property |Description |Type |Nullable

.^|context-path
|Context-path
^.^|string
^.^|-

.^|resolved-path
|Resolved-path is the path defined in policies
^.^|string
^.^|-

.^|application
|The authenticated application doing incoming HTTP request
^.^|string
^.^|X (for keyless plan)

.^|api
|Called API
^.^|string
^.^|-

.^|user-id
|The user identifier of incoming HTTP request:

* The subscription id for api-key based plan

* Remote IP for keyless based plan

^.^|string
^.^|-

.^|plan
|Plan used to manage incoming HTTP request
^.^|string
^.^|-

.^|api-key
|the api-key used (in case of an api-key based plan)
^.^|string
^.^|X (for no api-key plan)
|===

Also, some policies (like the link:/apim/3.x/apim_policies_oauth2.html#attributes[OAuth2 policy])
are registering some other attributes in the context. Please check the
documentation of the policies you are using to be aware of them.

=== Example

* Get the value of the `user-id` attribute for an incoming HTTP request:

`{#context.attributes['user-id']}`

* Get the value of the `plan` attribute for an incoming HTTP request:

`{#context.attributes['plan']}`

* Check that the path starts with a given value:

`{#request.path.startsWith('/my/api')}`

== Policies
Expression language can be used to configure some part of policies configuration.
It's up to the policy to specify if its supports EL or not.

== Mixin

In previous examples, we show several examples to manipulate objects available
in the EL context. One amazing thing you can also achieve is to mix property
usage to provide a more and more dynamic configuration.

As an example, we would like to retrieve the value of an HTTP header where the name
is based on an API property named `my-property`:

`{#request.headers[#properties['my-property']]}`
